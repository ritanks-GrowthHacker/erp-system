import { NextRequest, NextResponse } from 'next/server';
import { erpDb } from '@/lib/db';
import { supplierQuotationSubmissions, suppliers } from '@/lib/db/schema';
import { eq, desc, sql } from 'drizzle-orm';
import { jwtVerify } from 'jose';

const JWT_SECRET = new TextEncoder().encode(
  process.env.JWT_SECRET || 'your-secret-key-change-in-production'
);

async function verifySupplierToken(req: NextRequest) {
  const authHeader = req.headers.get('authorization');
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return null;
  }

  try {
    const token = authHeader.substring(7);
    const { payload } = await jwtVerify(token, JWT_SECRET);
    
    if (payload.type !== 'supplier') {
      return null;
    }

    return payload;
  } catch (error) {
    return null;
  }
}

// GET /api/supplier-portal/quotations - Get all quotations submitted by supplier
export async function GET(req: NextRequest) {
  const supplier = await verifySupplierToken(req);
  
  if (!supplier) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }

  try {
    const quotations = await erpDb.query.supplierQuotationSubmissions.findMany({
      where: eq(supplierQuotationSubmissions.supplierId, supplier.supplierId as string),
      orderBy: [desc(supplierQuotationSubmissions.submissionDate)]
    });
    
    console.log('Fetched quotations:', quotations.length, 'records');

    return NextResponse.json({ quotations });
  } catch (error: any) {
    console.error('Error fetching quotations:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// POST /api/supplier-portal/quotations - Submit new quotation
export async function POST(req: NextRequest) {
  const supplier = await verifySupplierToken(req);
  
  if (!supplier) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }

  try {
    const body = await req.json();
    const {
      rfqId,
      purchaseOrderId,
      quotationType, // 'file_upload' or 'manual_entry'
      fileUrl,
      fileName,
      fileType,
      fileSize,
      manualQuotationData,
      totalAmount,
      currencyCode,
      validityDays,
      deliveryTimeInDays,
      paymentTerms,
      notes,
    } = body;

    if (!quotationType || (quotationType !== 'file_upload' && quotationType !== 'manual_entry')) {
      return NextResponse.json(
        { error: 'Invalid quotation type' },
        { status: 400 }
      );
    }

    if (quotationType === 'file_upload' && !fileUrl) {
      return NextResponse.json(
        { error: 'File is required for file upload type' },
        { status: 400 }
      );
    }

    if (quotationType === 'manual_entry' && !manualQuotationData) {
      return NextResponse.json(
        { error: 'Quotation data is required for manual entry type' },
        { status: 400 }
      );
    }

    // Calculate valid_until date if validityDays is provided
    let validUntil = null;
    if (validityDays && validityDays > 0) {
      const today = new Date();
      today.setDate(today.getDate() + validityDays);
      validUntil = today.toISOString().split('T')[0]; // Format as YYYY-MM-DD
    }

    // Create quotation submission
    const [quotation] = await erpDb
      .insert(supplierQuotationSubmissions)
      .values({
        supplierId: supplier.supplierId as string,
        rfqId: rfqId || null,
        purchaseOrderId: purchaseOrderId || null,
        submissionNumber: '', // Will be auto-generated by trigger
        quotationType,
        fileUrl: fileUrl || null,
        fileName: fileName || null,
        fileType: fileType || null,
        fileSize: fileSize || null,
        manualQuotationData: manualQuotationData || null,
        totalAmount: totalAmount || null,
        currencyCode: currencyCode || 'INR',
        validUntil: validUntil || null,
        deliveryTimeInDays: deliveryTimeInDays || null,
        paymentTerms: paymentTerms || null,
        notes: notes || null,
        status: 'submitted',
      })
      .returning();

    // If manual entry, save to manual_quotations table
    if (quotationType === 'manual_entry' && manualQuotationData) {
      try {
        // Get supplier's ERP organization
        const supplierData = await erpDb.query.suppliers.findFirst({
          where: eq(suppliers.id, supplier.supplierId as string),
        });

        if (!supplierData) {
          throw new Error('Supplier not found');
        }

        // Insert manual quotation header
        const manualQuotationResult = await erpDb.execute(sql`
          INSERT INTO manual_quotations (
            quotation_id, supplier_id, erp_organization_id,
            notes, terms, payment_terms, delivery_terms, validity_days,
            subtotal, tax_amount, discount_amount, shipping_charges, total_amount
          ) VALUES (
            ${quotation.id}, ${supplier.supplierId}, ${supplierData.erpOrganizationId},
            ${manualQuotationData.notes || null}, ${manualQuotationData.terms || null},
            ${manualQuotationData.paymentTerms || paymentTerms || null},
            ${manualQuotationData.deliveryTerms || null}, ${validityDays || 30},
            ${manualQuotationData.subtotal || 0}, ${manualQuotationData.taxAmount || 0},
            ${manualQuotationData.discountAmount || 0}, ${manualQuotationData.shippingCharges || 0},
            ${totalAmount || 0}
          ) RETURNING id
        `);

        const manualQuotationId = Array.from(manualQuotationResult)[0]?.id;

        // Insert manual quotation items
        if (manualQuotationData.items && Array.isArray(manualQuotationData.items)) {
          for (const item of manualQuotationData.items) {
            await erpDb.execute(sql`
              INSERT INTO manual_quotation_items (
                manual_quotation_id, product_name, product_code, description,
                quantity, unit_price, tax_rate, tax_amount,
                discount_percent, discount_amount, line_total,
                unit_of_measure, delivery_time_days, notes
              ) VALUES (
                ${manualQuotationId}, ${item.productName || item.product}, 
                ${item.productCode || null}, ${item.description || null},
                ${item.quantity || item.qty || 0}, ${item.unitPrice || item.price || 0},
                ${item.taxRate || 0}, ${item.taxAmount || item.tax || 0},
                ${item.discountPercent || 0}, ${item.discountAmount || 0},
                ${item.lineTotal || (item.quantity * item.unitPrice)},
                ${item.unitOfMeasure || 'PCS'}, ${item.deliveryTimeDays || deliveryTimeInDays || null},
                ${item.notes || null}
              )
            `);
          }
        }
      } catch (error) {
        console.error('Error saving manual quotation data:', error);
        // Don't fail the entire request if manual quotation storage fails
        // The data is still in JSONB format
      }
    }

    return NextResponse.json({
      success: true,
      message: 'Quotation submitted successfully',
      quotation,
    });
  } catch (error: any) {
    console.error('Error submitting quotation:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
